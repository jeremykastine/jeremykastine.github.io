<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Augmentation Canon Puzzle</title>
<style>
    body, html {
        touch-action: none;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
    }   

    body {
            margin: 0;
            font-family: Arial, sans-serif;
        }



    #myCanvas {
        position: absolute;
        /*background-color: lightblue;*/
        touch-action: none;
        position: absolute;
        transform-origin: 0 0;
        top: 0;
        left: 0;
        user-select: none;
        z-index: 1;
    }
    #myCanvas2 {
        position: absolute;
        touch-action: none;
        user-select: none;
        z-index: 0;
        top: 0;
        left: 0;
        border: 1px solid black;
    }


</style>
</head>
<body>
    
    <canvas id="myCanvas"></canvas>
    <canvas id="myCanvas2"></canvas>


    


    

    <script>
        const getHeight = () => {
        if (window.visualViewport) {
            return window.visualViewport.height;  // Use visualViewport on supported browsers
        }
        return window.innerHeight;  // Fallback for older browsers
        };
        const getWidth = () => {
        if (window.visualViewport) {
            return window.visualViewport.width;  // Use visualViewport on supported browsers
        }
        return window.innerWidth;  // Fallback for older browsers
        };

        let sliderValue = .5;
        const colorArray=['blue','red','green','purple','orange'];
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        const levelParam = urlParams.get('level');
        let partList = levelParam.split(",").map(Number);
        partList=partList.map(x => x - Math.min(...partList));
        let noteList = [];
        for(let i = 0;i<=Math.max(...partList);i++){
            let j = 0;
            for(let k = 0;k<partList.length;k++){
                if(partList[k]==i){
                    noteList[k]=j;
                    j++;
                }
            }
        }
        
        let rhythm = [];
        for(let i=0; i<=Math.max(...noteList);i++){
            rhythm[i]=i/(Math.max(...noteList));
        }
        let leftEndpointConfig=[];
        let rightEndpointConfig=[];
        for(let i =0;i<noteList.length;i++){
            if(noteList[i]==0){
                leftEndpointConfig[partList[i]]=i/(noteList.length-1);
            }
            if(noteList[i]==rhythm.length-1){
                rightEndpointConfig[partList[i]]=i/(noteList.length-1);
            }
        }
        
        let leftEndpoint = [];
        let rightEndpoint = [];
        let numParts = Math.max(...partList)+1;
        for(let i=0;i<numParts;i++){
            leftEndpoint[i]=i*rhythm.length/(numParts*rhythm.length-1);
            rightEndpoint[i]=((i+1)*rhythm.length-1)/(numParts*rhythm.length-1);
        }


        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const canvas2 = document.getElementById('myCanvas2');
        const ctx2 = canvas2.getContext('2d');
        let selected = -1;

        let portrait = true;
        function resizeCanvas() {
            if(window.innerHeight>window.innerWidth){
                portrait=true;
                canvas.width = getHeight();
                canvas.height = getWidth();
                myCanvas.style.transform = 'rotate(-90deg) scale(-1,1)';
                canvas2.width = getWidth();
                canvas2.height = getHeight();
            } else {
                portrait=false;
                canvas.width = getWidth();
                canvas.height = getHeight();
                myCanvas.style.transform = ``;
                canvas2.width = getWidth();
                canvas2.height = getHeight();
            }
        }
        let margin=30;
        function xOfNote(i){
            let x=rhythm[noteList[i]];
            x=x*(rightEndpoint[partList[i]]-leftEndpoint[partList[i]]);
            x=x+leftEndpoint[partList[i]];
            return margin+x*(canvas.width-2*margin);
        }
        function xOfConfig(i){
            return margin+i/(partList.length-1)*(canvas.width-2*margin)
        }

        
        function tOfNote(i){
            let x=rhythm[noteList[i]];
            x=x*(rightEndpoint[partList[i]]-leftEndpoint[partList[i]]);
            x=x+leftEndpoint[partList[i]];
            return x;
        }

        function yOfConfig(i){
            return yOfDiagTop()*(i+1)/(leftEndpoint.length+1);
        }
        function yOfDiagTop(){
            return canvas.height*.28;
        }
        function yOfDiagBot(){
            return canvas.height*.56;
        }
        function yOfPart(i){
            return yOfDiagBot()+(yOfSliderBound()-yOfDiagBot())*(i+1)/(leftEndpoint.length+1);
        }
        function yOfSliderBound(){
            return canvas.height*.84;
        }
        
        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(selected>-1){
                ctx.beginPath();
                ctx.arc(margin*2+sliderValue*(canvas.width-4*margin),(canvas.height+yOfSliderBound())/2,(canvas.height-yOfSliderBound())/4,0,6.28);
                ctx.fillStyle='LightGray';
                ctx.fill();
            }
            ctx.lineWidth = .001*canvas.width;
            
            ctx.beginPath();
            ctx.moveTo(0,yOfSliderBound());
            ctx.lineTo(canvas.width,yOfSliderBound());
            ctx.moveTo(0,yOfDiagBot());
            ctx.lineTo(canvas.width,yOfDiagBot());
            ctx.moveTo(0,yOfDiagTop());
            ctx.lineTo(canvas.width,yOfDiagTop());
            ctx.strokeStyle="black";
            ctx.stroke();

            ctx.globalAlpha = .25;
            for(let i=0;i<partList.length;i++){
                ctx.strokeStyle=colorArray[partList[i]];
                ctx.beginPath();
                ctx.moveTo(xOfConfig(i),yOfConfig(partList[i]));
                ctx.lineTo(xOfConfig(i),yOfDiagTop());
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(xOfNote(i),yOfDiagBot());
                ctx.lineTo(xOfNote(i),yOfPart(partList[i]));
                ctx.stroke();
            }
            
            for(let i=0;i<leftEndpoint.length;i++){
                ctx.strokeStyle=colorArray[i];
                ctx.beginPath();
                ctx.moveTo(margin+(canvas.width-2*margin)*leftEndpoint[i],yOfPart(i));
                ctx.lineTo(margin+(canvas.width-2*margin)*rightEndpoint[i],yOfPart(i));
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(margin+(canvas.width-2*margin)*leftEndpointConfig[i],yOfConfig(i));
                ctx.lineTo(margin+(canvas.width-2*margin)*rightEndpointConfig[i],yOfConfig(i));
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            for(let i=0;i<partList.length;i++){
                let r=1;
                if(selected>-1){
                    if(noteList[selected]==0){
                        if(partList[i]==partList[selected]){
                            r=2-noteList[i]/(rhythm.length-1)
                        }
                    } else if(noteList[selected]==rhythm.length-1){
                        if(partList[i]==partList[selected]){
                            r=1+noteList[i]/(rhythm.length-1);
                        }
                    } else {
                        if(noteList[i]==noteList[selected]){
                            r=2;
                        }
                    }
                }
                ctx.beginPath();
                ctx.arc(xOfConfig(i),yOfConfig(partList[i]),canvas.width/(partList.length*15)*r,0,6.28);
                ctx.fillStyle=colorArray[partList[i]];
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(xOfConfig(i),yOfDiagTop());
                ctx.lineTo(xOfNote(i),yOfDiagBot());
                ctx.lineWidth = (r*.002-.001)*canvas.width;;
                ctx.strokeStyle=colorArray[partList[i]];
                ctx.stroke();

                ctx.fillStyle=colorArray[partList[i]];
                ctx.beginPath();
                ctx.arc(xOfNote(i),yOfPart(partList[i]),canvas.width/(partList.length*15)*r,0,6.28);
                ctx.fill();
            }
            let minGapSize = 9999;
            let minGapLocation = -1;
            for(let i=0;i<partList.length-1;i++){
                if(tOfNote(i+1)-tOfNote(i)<minGapSize){
                    minGapSize = tOfNote(i+1)-tOfNote(i);
                    minGapLocation = (xOfNote(i)+xOfNote(i+1)+xOfConfig(i)+xOfConfig(i+1))/4;
                }
            }

            let score =Math.max(0,Math.ceil(minGapSize*(partList.length-1)*100));
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            if(score>0){
                ctx2.font = (canvas.width-2*margin)/(3*partList.length)+'px Arial'; //
                ctx2.fillStyle = 'Gray'; // Fill color for text
                ctx2.textAlign = 'center';
                ctx2.textBaseline = "middle";
                let textY = (yOfDiagBot()+yOfDiagTop())/2;
                console.log(minGapLocation,textY);
                if(portrait){
                    ctx2.fillText(score,textY,minGapLocation);
                } else {
                    ctx2.fillText(score,minGapLocation,textY);
                }
            }
            
            
            
            //ctx.fillText(score,50,50);

        }


        window.addEventListener('resize', () => {
            resizeCanvas();
            drawCanvas();
        });

        let isDragging = false;

        canvas.addEventListener('pointerdown', (e) => {
            console.log(1);
            const rect = canvas.getBoundingClientRect();
            let x;
            let y;
            if(portrait){
                x = event.clientY - rect.top;
                y = event.clientX - rect.left;
            } else {
                x = event.clientX - rect.left;
                y = event.clientY - rect.top;
            }


            if(y>yOfSliderBound()){
                
                isDragging = true;
                updateSlider(x);
            } else {
                let prevSelected = selected;
                if(y<yOfDiagTop()){ 
                    selected = -1;
                    let minDist = 9999;
                    for(let i=0;i<partList.length;i++){
                        let d = Math.sqrt((xOfConfig(i)-x)**2+(yOfConfig(partList[i])-y)**2);
                        if(d<minDist){
                            minDist = d;
                            selected = i;
                        }
                    }
                } else if(y>yOfDiagBot()){
                    selected = -1;
                    let minDist = 9999;
                    for(let i=0;i<partList.length;i++){
                        let d = Math.sqrt((xOfNote(i)-x)**2+(yOfPart(partList[i])-y)**2);
                        if(d<minDist){
                            minDist = d;
                            selected = i;
                        }
                    }
                }
                
                if(selected==prevSelected){
                    selected=-1;
                } else {
                    if(noteList[selected]==0){
                        sliderValue = leftEndpoint[partList[selected]]/rightEndpoint[partList[selected]];
                    } else if(noteList[selected]==rhythm.length-1){
                        sliderValue = (rightEndpoint[partList[selected]]-leftEndpoint[partList[selected]])/(1-leftEndpoint[partList[selected]]);
                    } else {
                        sliderValue = (rhythm[noteList[selected]]-rhythm[noteList[selected]-1])/(rhythm[noteList[selected]+1]-rhythm[noteList[selected]-1]);
                    }
                }

                drawCanvas();
            } 
            
        });

        canvas.addEventListener('pointermove', (e) => {
            const rect = canvas.getBoundingClientRect();
            if (isDragging) {
                if(portrait){
                    x = event.clientY - rect.top;
                } else {
                    x = event.clientX - rect.left;
                }
                updateSlider(x);
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            isDragging = false;
        });
        canvas.addEventListener('pointercancel', () => {
            isDragging = false;
        });
        canvas.addEventListener('pointerout', () => {
            isDragging = false;
        });

        function updateSlider(x){
            if(portrait){
                sliderValue = (x-2*margin)/(canvas.width-4*margin);
            } else {
                sliderValue = (x-2*margin)/(canvas.width-4*margin);
            }
            if(sliderValue>1){sliderValue=1}
            if(sliderValue<0){sliderValue=0}
            updateCanonValues();
            drawCanvas();
        }
        function updateCanonValues(){
            if(selected>-1){
                if(noteList[selected]==0){
                    leftEndpoint[partList[selected]]=sliderValue*rightEndpoint[partList[selected]];
                } else if(noteList[selected]==rhythm.length-1){
                    rightEndpoint[partList[selected]]=leftEndpoint[partList[selected]]+sliderValue*(1-leftEndpoint[partList[selected]]);
                } else {
                    rhythm[noteList[selected]]=rhythm[noteList[selected]-1] + sliderValue * (rhythm[noteList[selected]+1]-rhythm[noteList[selected]-1]);
                }
            }
        }

        resizeCanvas();
        drawCanvas();
        



    </script>
</body>
</html>
